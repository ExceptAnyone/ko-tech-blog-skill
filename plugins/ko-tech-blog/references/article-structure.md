# 기술 블로그 글 구조 가이드

## 전체 구조 (문제 해결형)

```
1. 제목 (숫자형/질문형/대비형)
2. 서론 (공감 유도)
3. 문제 정의 (구체적 상황 + 영향)
4. 해결 과정 (Phase 1/2/3)
5. 결과 (정성 + 정량)
6. 배운 점 (인사이트 + 여운)
7. 참고 자료
```

---

## 1. 제목 작성법

### 숫자형
**패턴**: [숫자] + [동사] + [명사]

**예시:**
- "3가지 방법으로 Next.js 빌드 속도 10배 개선하기"
- "5단계로 완성하는 타입 안전한 API 클라이언트"
- "7가지 React 렌더링 최적화 기법"

**장점:**
- 구체적이고 명확함
- 클릭을 유도
- SEO에 유리

---

### 질문형
**패턴**: [질문]

**예시:**
- "왜 우리는 TypeScript를 선택했을까?"
- "React Query가 정말 필요할까?"
- "모노레포는 은탄환일까?"

**장점:**
- 호기심 유발
- 독자와 대화하는 느낌
- 문제 의식 공유

---

### 대비형
**패턴**: [Before] → [After]

**예시:**
- "느린 API 응답 → 0.3초로 단축한 이야기"
- "10분 배포 → 30초 배포까지"
- "복잡한 상태 관리 → 단순하게 바꾼 방법"

**장점:**
- 변화를 직관적으로 보여줌
- 결과 중심
- 임팩트 강조

---

## 2. 서론 작성법

### 목적
- 독자의 공감 유도
- 문제 상황에 빠르게 몰입시키기
- 기술 용어보다는 감정과 상황 묘사

### 패턴 1: 질문형 시작
```markdown
"배포할 때마다 왜 이렇게 오래 걸릴까?"

개발자라면 누구나 한 번쯤 겪어봤을 거예요.
코드를 수정하고, 커밋하고, 푸시하고, 배포하는데...
커피 한 잔 마실 시간이 필요하죠.
```

### 패턴 2: 공감 유도
```markdown
개발자라면 누구나 한 번쯤 이런 생각을 해봤을 거예요.

"이 코드, 왜 이렇게 복잡하지?"
"더 간단하게 만들 수 없을까?"
```

### 패턴 3: 구체적 상황 묘사
```markdown
월요일 아침 9시, 슬랙 알림이 울렸어요.

"사이트가 느려요!"

커피를 들고 모니터를 확인했어요. 응답 시간이 3초...
```

### 체크리스트
- [ ] 독자가 공감할 수 있는 상황인가?
- [ ] 일상적 언어로 작성했는가?
- [ ] 기술 용어를 남발하지 않았는가?
- [ ] 감정과 상황이 묘사되었는가?
- [ ] 다음 섹션으로 자연스럽게 연결되는가?

---

## 3. 문제 정의 작성법

### 목적
- 해결하고자 한 문제를 명확히
- 문제의 중요성 설명 (비즈니스/사용자 영향)
- 독자가 "이건 심각하네" 하고 생각하게 만들기

### 구조
```
1. 구체적인 문제 상황
2. 문제가 미친 영향 (비즈니스/사용자/개발자)
3. 블록 인용(>)으로 핵심 질문 강조
```

### 예시 1: 성능 문제
```markdown
## 문제 정의

사용자가 상품 목록을 볼 때마다 3초씩 기다려야 했어요.
1초면 짧지만, 3초는 영원처럼 느껴지죠.

실제로 데이터를 분석해보니 구매 전환율이 **30%나 떨어져** 있었어요.
페이지 이탈률도 **50%**를 넘었고요.

매일 같은 상품 정보를 **100만 번** 이상 데이터베이스에서 조회하고 있었어요.
서버 비용도 매달 증가하는 추세였죠.

> 왜 같은 데이터를 매번 데이터베이스에서 조회해야 할까?
```

### 예시 2: 개발 프로세스 문제
```markdown
## 문제 상황

배포 한 번 하는 데 **10분**이 걸렸어요.

빌드 → 테스트 → 배포 과정을 모두 거쳐야 했거든요.
작은 오타 수정에도 10분을 기다려야 했죠.

팀원들은 배포를 두려워하기 시작했어요.
"이거 배포해도 될까요?" "나중에 한꺼번에 배포하죠."

하루 배포 횟수가 **2회**에 불과했어요.
빠른 피드백이 필요한 스타트업 환경에서는 치명적이었죠.

> 배포가 이렇게 무거워야 할까?
```

### 체크리스트
- [ ] 문제가 구체적으로 설명되었는가?
- [ ] 숫자(정량적 지표)가 포함되었는가?
- [ ] 비즈니스/사용자 영향이 명확한가?
- [ ] 블록 인용(>)으로 핵심 질문을 강조했는가?
- [ ] 독자가 "이건 해결해야겠다"고 생각하게 만드는가?

---

## 4. 해결 과정 작성법 (Phase 구조)

### 목적
- 시행착오를 투명하게 공유
- 단계적 발전 과정 보여주기
- 각 시도에서 배운 점 전달

### Phase 구조
```
Phase 1: 첫 번째 시도 (가장 쉬운 방법)
  → 시도 내용
  → 코드 예시: Before
  → 발견한 문제점

Phase 2: 개선 (문제점 해결)
  → 개선 방법
  → 코드 예시: 개선 버전
  → 결과와 남은 과제

Phase 3: 최종 해결책 (완성도 높이기)
  → 최종 솔루션
  → 코드 예시: 최종 버전
  → 구체적 구현
```

---

### Phase 1: 첫 번째 시도

**작성 가이드:**
- 가장 쉽거나 직관적인 방법부터
- 반말로 생각을 인용 (예: "일단 이렇게 하면 되지 않을까?")
- 간단한 구현과 즉각적인 결과
- 발견한 문제점 솔직하게

**예시:**
```markdown
### Phase 1: 가장 간단한 방법

"일단 로컬 메모리에 캐싱하면 되지 않을까?"

첫 번째 시도는 간단했어요. Node.js의 `Map` 객체를 사용해서 메모리에 데이터를 캐싱했죠.

**Before: 매번 데이터베이스 조회**
\`\`\`typescript
async function getProduct(id: string) {
  // 매번 DB 조회
  return await db.product.findUnique({ where: { id } });
}
\`\`\`

**After: Map으로 캐싱**
\`\`\`typescript
const cache = new Map<string, Product>();

async function getProduct(id: string) {
  // 캐시 확인
  if (cache.has(id)) {
    return cache.get(id);
  }

  // 캐시 미스 시 DB 조회
  const product = await db.product.findUnique({ where: { id } });
  cache.set(id, product);

  return product;
}
\`\`\`

구현도 쉬웠고, 성능도 좋았어요. 응답 시간이 **3초에서 0.5초**로 줄었거든요.

하지만 곧 문제를 발견했어요.

서버를 재시작할 때마다 캐시가 날아가는 거예요.
배포할 때마다 사용자들이 느린 페이지를 경험해야 했죠.
```

---

### Phase 2: 개선

**작성 가이드:**
- Phase 1의 문제점을 해결하기 위한 시도
- 왜 이 방법을 선택했는지
- 개선된 결과와 새로운 과제

**예시:**
```markdown
### Phase 2: Redis 도입

"영구적인 저장소가 필요해."

Redis를 도입했어요. 캐시가 서버 재시작과 무관하게 유지되었죠.

**개선 버전: Redis 캐싱**
\`\`\`typescript
import Redis from 'ioredis';
const redis = new Redis();

async function getProduct(id: string) {
  // 1. Redis 캐시 확인
  const cached = await redis.get(`product:${id}`);
  if (cached) {
    return JSON.parse(cached);
  }

  // 2. 캐시 미스 시 DB 조회
  const product = await db.product.findUnique({ where: { id } });

  // 3. Redis에 저장 (TTL 1시간)
  await redis.set(
    `product:${id}`,
    JSON.stringify(product),
    'EX',
    3600
  );

  return product;
}
\`\`\`

배포해도 캐시가 유지되었고, 응답 시간도 **0.3초**로 더 빨라졌어요.

그런데 새로운 문제가 생겼어요.

상품 정보가 업데이트되어도 캐시는 그대로였거든요.
관리자가 가격을 수정해도 사용자에게는 예전 가격이 보이는 거죠.

> 언제 캐시를 지워야 할까?
```

---

### Phase 3: 최종 해결책

**작성 가이드:**
- 최종적으로 선택한 방법과 이유
- 세부 구현 로직
- 왜 이 방법이 최선인지

**예시:**
```markdown
### Phase 3: 스마트한 무효화 전략

"데이터가 변경되면 즉시 캐시를 지우자."

최종적으로는 **이벤트 기반 캐시 무효화**를 도입했어요.

상품 정보가 업데이트되면, 해당 상품의 캐시를 즉시 삭제하는 거죠.

**최종 버전: 이벤트 기반 무효화**
\`\`\`typescript
import Redis from 'ioredis';
const redis = new Redis();

// 상품 조회
async function getProduct(id: string) {
  const cached = await redis.get(`product:${id}`);
  if (cached) return JSON.parse(cached);

  const product = await db.product.findUnique({ where: { id } });
  await redis.set(`product:${id}`, JSON.stringify(product), 'EX', 3600);

  return product;
}

// 상품 업데이트 + 캐시 무효화
async function updateProduct(id: string, data: UpdateData) {
  // 1. DB 업데이트
  const updated = await db.product.update({
    where: { id },
    data,
  });

  // ⚠️ 핵심: 캐시 즉시 삭제
  await redis.del(`product:${id}`);

  return updated;
}

// 💡 포인트: Prisma middleware로 자동화
prisma.$use(async (params, next) => {
  const result = await next(params);

  // 상품 수정 시 자동으로 캐시 삭제
  if (params.model === 'Product' && params.action === 'update') {
    await redis.del(`product:${params.args.where.id}`);
  }

  return result;
});
\`\`\`

이제 데이터 정합성 문제가 해결되었어요.

관리자가 상품 정보를 수정하면, 즉시 캐시가 삭제되고,
다음 요청 때 새로운 데이터가 캐시에 저장되죠.

Prisma middleware를 사용해서 모든 업데이트 작업에 자동으로 적용했어요.
개발자가 캐시 무효화를 신경 쓸 필요가 없죠.
```

---

### Phase별 체크리스트
- [ ] 각 Phase의 목적이 명확한가?
- [ ] 시도 → 결과 → 문제점 → 배움 흐름이 있는가?
- [ ] Before/After 코드 예시가 있는가?
- [ ] 주석으로 핵심 로직을 강조했는가?
- [ ] 실패와 시행착오를 솔직하게 공유했는가?
- [ ] Phase 1 → 2 → 3로 점진적 발전이 보이는가?

---

## 5. 결과 작성법

### 목적
- 해결책의 효과 입증
- 정성적 변화(경험, 문화)와 정량적 수치 모두 제시
- 독자에게 "이 방법이 효과적이구나" 확신 주기

### 구조
```
1. 정성적 변화 (사용자 경험, 팀 문화, 개발 프로세스)
2. 정량적 수치 (Before → After)
3. 부가적인 효과
```

### 예시 1: 성능 개선
```markdown
## 결과

페이지 응답 시간이 **3초에서 0.3초**로 줄었어요.

더 중요한 건 숫자가 아니었어요. 사용자들의 경험이 완전히 달라졌거든요.

"페이지가 빨라졌어요!" 고객 센터로 긍정적인 피드백이 쏟아졌어요.
구매 전환율이 **30% 증가**했고, 페이지 이탈률은 **50%에서 15%**로 떨어졌죠.

서버 비용도 절감되었어요. 데이터베이스 조회가 **90% 감소**하면서 서버 비용이 **월 100만 원** 줄었거든요.

### 주요 지표

| 지표 | Before | After | 개선율 |
|------|--------|-------|--------|
| 응답 시간 | 3초 | 0.3초 | **90% 감소** |
| 구매 전환율 | 20% | 26% | **30% 증가** |
| 페이지 이탈률 | 50% | 15% | **70% 감소** |
| DB 조회 수 | 100만/일 | 10만/일 | **90% 감소** |
| 서버 비용 | 월 150만원 | 월 50만원 | **67% 절감** |
```

### 예시 2: 개발 프로세스 개선
```markdown
## 결과

배포 시간이 **10분에서 30초**로 줄었어요.

더 중요한 건 숫자가 아니었어요. 팀원들이 배포를 두려워하지 않게 된 거죠.

"배포 한 번 할까요?"라는 말이 이제는 가벼워졌어요.
오타 수정도, 작은 개선도, 즉시 배포할 수 있게 되었죠.

하루 배포 횟수가 **2회에서 15회**로 늘었어요.
빠른 피드백 덕분에 버그도 빨리 발견하고, 빨리 고칠 수 있었고요.

개발자들의 만족도도 높아졌어요. 사내 설문에서 "배포 프로세스 만족도"가 **5점에서 9점**으로 올랐거든요.
```

### 체크리스트
- [ ] 정성적 변화를 먼저 설명했는가?
- [ ] 정량적 수치를 굵은 텍스트로 강조했는가?
- [ ] Before → After 비교가 명확한가?
- [ ] 주요 지표를 표로 정리했는가? (선택)
- [ ] 부가적인 효과(비용 절감, 팀 문화 등)를 언급했는가?

---

## 6. 배운 점 작성법

### 목적
- 단순한 기술 공유를 넘어 인사이트 전달
- 독자에게 "생각할 거리" 제공
- 철학적 전환이나 확장된 사고 제시
- 여운을 남기는 마무리

### 구조
```
1. 핵심 인사이트 (이번 경험을 통해 배운 것)
2. 철학적 전환 또는 확장된 사고 (더 큰 그림)
3. 여운을 남기는 마무리 (질문, 초대, 미래)
```

### 예시 1: 기술 선택의 교훈
```markdown
## 배운 점

이번 경험을 통해 배운 건 **"완벽한 해결책은 없다"**는 거예요.

Phase 1의 간단한 캐싱도, Phase 2의 Redis도, 모두 장단점이 있었죠.
중요한 건 **현재 문제에 가장 적합한 방법을 찾는 거**예요.

처음부터 완벽한 설계를 고민하느라 시간을 낭비하지 마세요.
작은 것부터 시도하고, 문제를 발견하고, 개선하는 게 더 빠른 길이에요.

> 기술은 수단이에요. 목적은 사용자에게 더 나은 경험을 주는 거죠.

아직 해결하지 못한 과제도 있어요. 캐시 워밍 전략, 분산 환경에서의 캐시 일관성...
하지만 우리는 계속 나아가고 있어요.

여러분은 어떤 방법을 사용하시나요?
```

### 예시 2: 프로세스 개선의 교훈
```markdown
## 배운 점

가장 중요한 깨달음은 **"빠른 것이 완벽한 것을 이긴다"**는 거예요.

10분짜리 완벽한 배포보다, 30초짜리 충분히 좋은 배포가 더 나아요.
빠른 피드백이 완벽한 계획보다 중요하거든요.

팀 문화도 바뀌었어요. "나중에 한꺼번에"가 아니라 "지금 바로"로요.
작은 변화를 자주 배포하는 게 큰 변화를 한 번에 배포하는 것보다 안전해요.

> 완벽을 추구하다가 기회를 놓치지 마세요.

기술적 부채를 두려워할 필요 없어요. 빠르게 시도하고, 배우고, 개선하면 되니까요.

여러분의 팀은 하루에 몇 번 배포하시나요?
```

### 예시 3: 단순함의 가치
```markdown
## 배운 점

복잡한 게 좋은 건 아니에요.

처음엔 마이크로서비스, 이벤트 소싱, CQRS 같은 멋진 아키텍처를 고민했어요.
하지만 우리에게 필요한 건 **Redis 한 줄**이었죠.

> 문제를 복잡하게 만드는 건 쉬워요. 단순하게 유지하는 게 어렵죠.

기술은 목적이 아니라 수단이에요.
사용자가 원하는 건 빠른 페이지지, 멋진 아키텍처가 아니거든요.

아직도 배우고 있어요. 더 단순하게, 더 효과적으로 만드는 방법을요.

여러분은 어떻게 단순함을 유지하시나요?
```

### 체크리스트
- [ ] 핵심 인사이트가 명확한가?
- [ ] 기술을 넘어 철학적 사고를 제시했는가?
- [ ] 블록 인용(>)으로 핵심 메시지를 강조했는가?
- [ ] 독자에게 생각할 거리를 제공하는가?
- [ ] 여운을 남기는 마무리인가? (질문, 초대, 미래)

---

## 7. 참고 자료 작성법

### 목적
- 독자가 더 깊이 공부할 수 있도록
- 신뢰성 확보 (출처 명시)
- 관련 리소스 제공

### 카테고리
```
1. 공식 문서
2. 참고한 아티클
3. 오픈소스 프로젝트
4. 관련 블로그 글
5. 도구/라이브러리
```

### 예시
```markdown
## 참고 자료

### 공식 문서
- [Redis Documentation](https://redis.io/documentation)
- [Prisma Middleware](https://www.prisma.io/docs/concepts/components/prisma-client/middleware)

### 참고한 아티클
- [Caching Strategies and Best Practices](https://aws.amazon.com/caching/)
- [Cache Invalidation: The Hardest Problem](https://martinfowler.com/bliki/TwoHardThings.html)

### 오픈소스 프로젝트
- [ioredis](https://github.com/redis/ioredis)
- [node-cache-manager](https://github.com/node-cache-manager/node-cache-manager)

### 관련 글
- [우리 팀의 Redis 도입기](https://example.com)
- [캐시 무효화 전략 비교](https://example.com)
```

---

## 추가 팁

### 1. 이미지 활용
- **서론 직후**: 문제 상황 시각화
- **Phase별 끝**: Before/After 비교
- **결과 섹션**: 최종 결과물, 지표 차트

### 2. 코드 블록 작성
- 설명 먼저, 코드는 나중에
- Before/After 패턴 활용
- 주석으로 핵심 강조
- 너무 길면 핵심만 발췌

### 3. 문단 리듬
- 짧은 문단(1-3줄) + 긴 문단(5-7줄) 교대
- 강조하고 싶은 부분은 짧게
- 상황 설명은 길게

### 4. 강조 기법
- **굵은 텍스트**: 중요한 개념, 숫자
- `인라인 코드`: 기술 용어, 파일명, 명령어
- > 블록 인용: 핵심 질문, 깨달음
- 숫자 활용: "3가지", "10배", "0.3초"

### 5. 반말체 사용
- 현장 대사 직접 인용
- 생각의 흐름 표현
- 독자와 대화하는 느낌
